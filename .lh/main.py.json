{
    "sourceFile": "main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1725460824308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725461518949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n from fastapi import FastAPI, HTTPException\n from pydantic import BaseModel\n-import json\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n+from typing import List\n \n app = FastAPI()\n \n # Define the data model\n@@ -13,46 +13,51 @@\n     preferred_time: str\n     delivery_time: str\n \n @app.post(\"/process-data/\")\n-async def process_data(data: list[DeliveryData]):\n-    df = pd.json_normalize([item.dict() for item in data])\n-    \n-    # Convert time columns to datetime\n-    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-    \n-    # Analyze Data\n-    avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n-    avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+async def process_data(data: List[DeliveryData]):\n+    try:\n+        # Convert list of DeliveryData to DataFrame\n+        df = pd.json_normalize([item.dict() for item in data])\n+        \n+        # Convert time columns to datetime\n+        df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+        df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        \n+        # Analyze Data\n+        avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+        avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n \n-    if pd.isna(avg_preferred_time):\n-        avg_preferred_time = 0\n-    if pd.isna(avg_delivery_time):\n-        avg_delivery_time = 0\n+        if pd.isna(avg_preferred_time):\n+            avg_preferred_time = 0\n+        if pd.isna(avg_delivery_time):\n+            avg_delivery_time = 0\n \n-    analysis_result = {\n-        'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n-        'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n-    }\n-    \n-    # Create and save visualization\n-    plt.figure(figsize=(10, 6))\n-    plt.scatter(\n-        df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n-        df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n-        alpha=0.5\n-    )\n-    plt.title('Preferred Time vs Delivery Time')\n-    plt.xlabel('Preferred Time (Minutes since Midnight)')\n-    plt.ylabel('Delivery Time (Minutes since Midnight)')\n-    plt.grid(True)\n-    \n-    buf = io.BytesIO()\n-    plt.savefig(buf, format='png')\n-    buf.seek(0)\n-    img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-    \n-    return {\n-        'analysis_result': analysis_result,\n-        'visualization': f'data:image/png;base64,{img_base64}'\n-    }\n+        analysis_result = {\n+            'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n+            'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n+        }\n+        \n+        # Create and save visualization\n+        plt.figure(figsize=(10, 6))\n+        plt.scatter(\n+            df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n+            df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n+            alpha=0.5\n+        )\n+        plt.title('Preferred Time vs Delivery Time')\n+        plt.xlabel('Preferred Time (Minutes since Midnight)')\n+        plt.ylabel('Delivery Time (Minutes since Midnight)')\n+        plt.grid(True)\n+        \n+        buf = io.BytesIO()\n+        plt.savefig(buf, format='png')\n+        buf.seek(0)\n+        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n+        plt.close()  # Close the plot to free memory\n+        \n+        return {\n+            'analysis_result': analysis_result,\n+            'visualization': f'data:image/png;base64,{img_base64}'\n+        }\n+    except Exception as e:\n+        raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725462088943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,18 +15,31 @@\n \n @app.post(\"/process-data/\")\n async def process_data(data: List[DeliveryData]):\n     try:\n+        if not data:\n+            raise HTTPException(status_code=400, detail=\"No data provided\")\n+\n         # Convert list of DeliveryData to DataFrame\n-        df = pd.json_normalize([item.dict() for item in data])\n+        df = pd.DataFrame([item.dict() for item in data])\n         \n+        # Check if required columns are present\n+        if 'preferred_time' not in df.columns or 'delivery_time' not in df.columns:\n+            raise HTTPException(status_code=400, detail=\"Missing required columns\")\n+\n         # Convert time columns to datetime\n-        df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-        df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        try:\n+            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        except ValueError:\n+            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n+\n+        # Analyze Data\n+        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n         \n-        # Analyze Data\n-        avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n-        avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+        avg_preferred_time = df['preferred_time_minutes'].mean()\n+        avg_delivery_time = df['delivery_time_minutes'].mean()\n \n         if pd.isna(avg_preferred_time):\n             avg_preferred_time = 0\n         if pd.isna(avg_delivery_time):\n@@ -39,10 +52,10 @@\n         \n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n-            df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n-            df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n+            df['preferred_time_minutes'],\n+            df['delivery_time_minutes'],\n             alpha=0.5\n         )\n         plt.title('Preferred Time vs Delivery Time')\n         plt.xlabel('Preferred Time (Minutes since Midnight)')\n"
                },
                {
                    "date": 1725470510543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,12 +3,17 @@\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n+import pickle\n from typing import List\n \n app = FastAPI()\n \n+# Load the trained model\n+with open('trained_model.pkl', 'rb') as f:\n+    model = pickle.load(f)\n+\n # Define the data model\n class DeliveryData(BaseModel):\n     preferred_time: str\n     delivery_time: str\n@@ -32,9 +37,9 @@\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n         except ValueError:\n             raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n \n-        # Analyze Data\n+        # Convert time columns to minutes since midnight for analysis and prediction\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n@@ -49,8 +54,15 @@\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n         }\n         \n+        # Make predictions using the trained model\n+        X = df[['preferred_time_minutes']]\n+        predictions = model.predict(X)\n+        \n+        # Prepare prediction results\n+        prediction_results = list(predictions)\n+\n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n             df['preferred_time_minutes'],\n@@ -69,8 +81,9 @@\n         plt.close()  # Close the plot to free memory\n         \n         return {\n             'analysis_result': analysis_result,\n-            'visualization': f'data:image/png;base64,{img_base64}'\n+            'visualization': f'data:image/png;base64,{img_base64}',\n+            'predictions': prediction_results\n         }\n     except Exception as e:\n         raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725470849655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,20 +4,25 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n-from typing import List\n+from typing import List, Dict, Any\n \n app = FastAPI()\n \n # Load the trained model\n-with open('trained_model.pkl', 'rb') as f:\n-    model = pickle.load(f)\n+try:\n+    with open('trained_model.pkl', 'rb') as f:\n+        model = pickle.load(f)\n+except FileNotFoundError:\n+    raise RuntimeError(\"Trained model file not found.\")\n+except Exception as e:\n+    raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n-    preferred_time: str\n-    delivery_time: str\n+    preferred_time: str  # Assuming HH:MM format\n+    delivery_time: str   # Assuming HH:MM format\n \n @app.post(\"/process-data/\")\n async def process_data(data: List[DeliveryData]):\n     try:\n@@ -26,12 +31,8 @@\n \n         # Convert list of DeliveryData to DataFrame\n         df = pd.DataFrame([item.dict() for item in data])\n         \n-        # Check if required columns are present\n-        if 'preferred_time' not in df.columns or 'delivery_time' not in df.columns:\n-            raise HTTPException(status_code=400, detail=\"Missing required columns\")\n-\n         # Convert time columns to datetime\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n"
                },
                {
                    "date": 1725471092691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n-from typing import List, Dict, Any\n+from typing import List\n \n app = FastAPI()\n \n # Load the trained model\n"
                },
                {
                    "date": 1725473162835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,4 +87,26 @@\n             'predictions': prediction_results\n         }\n     except Exception as e:\n         raise HTTPException(status_code=500, detail=str(e))\n+\n+@app.post(\"/predict-delivery-time/\")\n+async def predict_delivery_time(data: DeliveryData):\n+    try:\n+        # Convert the input data to a DataFrame\n+        input_data = pd.DataFrame([data.dict()])\n+        input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n+        input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        \n+        # Make prediction\n+        prediction = model.predict(input_data[['preferred_time_minutes']])\n+        \n+        # Convert prediction to time format\n+        predicted_time = int(prediction[0])\n+        predicted_hours = predicted_time // 60\n+        predicted_minutes = predicted_time % 60\n+        \n+        return {\n+            'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n+        }\n+    except Exception as e:\n+        raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725475826784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,18 +5,25 @@\n import io\n import base64\n import pickle\n from typing import List\n+import logging\n \n app = FastAPI()\n \n+# Configure logging\n+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n+\n # Load the trained model\n try:\n     with open('trained_model.pkl', 'rb') as f:\n         model = pickle.load(f)\n+    logging.info(\"Trained model loaded successfully.\")\n except FileNotFoundError:\n+    logging.error(\"Trained model file not found.\")\n     raise RuntimeError(\"Trained model file not found.\")\n except Exception as e:\n+    logging.error(f\"Error loading model: {str(e)}\")\n     raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n@@ -45,12 +52,11 @@\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n         avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-        if pd.isna(avg_preferred_time):\n-            avg_preferred_time = 0\n-        if pd.isna(avg_delivery_time):\n-            avg_delivery_time = 0\n+        # Handle NaN values\n+        avg_preferred_time = avg_preferred_time if not pd.isna(avg_preferred_time) else 0\n+        avg_delivery_time = avg_delivery_time if not pd.isna(avg_delivery_time) else 0\n \n         analysis_result = {\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n@@ -86,8 +92,9 @@\n             'visualization': f'data:image/png;base64,{img_base64}',\n             'predictions': prediction_results\n         }\n     except Exception as e:\n+        logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n @app.post(\"/predict-delivery-time/\")\n async def predict_delivery_time(data: DeliveryData):\n@@ -108,5 +115,6 @@\n         return {\n             'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n         }\n     except Exception as e:\n+        logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725477034619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,21 +4,22 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n+import logging\n from typing import List\n-import logging\n \n+# Set up logging\n+logging.basicConfig(level=logging.INFO)\n+\n app = FastAPI()\n \n-# Configure logging\n-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n-\n # Load the trained model\n try:\n     with open('trained_model.pkl', 'rb') as f:\n         model = pickle.load(f)\n     logging.info(\"Trained model loaded successfully.\")\n+    logging.info(f\"Model type: {type(model)}\")  # Debugging line to check model type\n except FileNotFoundError:\n     logging.error(\"Trained model file not found.\")\n     raise RuntimeError(\"Trained model file not found.\")\n except Exception as e:\n@@ -52,20 +53,24 @@\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n         avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-        # Handle NaN values\n-        avg_preferred_time = avg_preferred_time if not pd.isna(avg_preferred_time) else 0\n-        avg_delivery_time = avg_delivery_time if not pd.isna(avg_delivery_time) else 0\n+        if pd.isna(avg_preferred_time):\n+            avg_preferred_time = 0\n+        if pd.isna(avg_delivery_time):\n+            avg_delivery_time = 0\n \n         analysis_result = {\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n         }\n         \n         # Make predictions using the trained model\n         X = df[['preferred_time_minutes']]\n-        predictions = model.predict(X)\n+        try:\n+            predictions = model.predict(X)\n+        except AttributeError:\n+            raise HTTPException(status_code=500, detail=\"Model does not have a predict method.\")\n         \n         # Prepare prediction results\n         prediction_results = list(predictions)\n \n"
                },
                {
                    "date": 1725480271472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,46 +1,39 @@\n-from fastapi import FastAPI, HTTPException\n+from fastapi import FastAPI, HTTPException, APIRouter\n from pydantic import BaseModel\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n-import pickle\n-import logging\n from typing import List\n+import json\n \n # Set up logging\n+import logging\n logging.basicConfig(level=logging.INFO)\n \n-app = FastAPI()\n-\n-# Load the trained model\n-try:\n-    with open('trained_model.pkl', 'rb') as f:\n-        model = pickle.load(f)\n-    logging.info(\"Trained model loaded successfully.\")\n-    logging.info(f\"Model type: {type(model)}\")  # Debugging line to check model type\n-except FileNotFoundError:\n-    logging.error(\"Trained model file not found.\")\n-    raise RuntimeError(\"Trained model file not found.\")\n-except Exception as e:\n-    logging.error(f\"Error loading model: {str(e)}\")\n-    raise RuntimeError(f\"Error loading model: {str(e)}\")\n-\n # Define the data model\n class DeliveryData(BaseModel):\n+    recipient_id: str\n     preferred_time: str  # Assuming HH:MM format\n+    delivery_date: str\n     delivery_time: str   # Assuming HH:MM format\n+    location: dict\n+    day_of_week: str\n+    special_event: str\n \n-@app.post(\"/process-data/\")\n-async def process_data(data: List[DeliveryData]):\n+process_data = APIRouter()\n+\n+@process_data.post(\"/process-data/\")\n+async def process_data_endpoint(data: List[DeliveryData]):\n     try:\n-        if not data:\n-            raise HTTPException(status_code=400, detail=\"No data provided\")\n+        # Load the JSON data\n+        with open('delivery.json', 'r') as file:\n+            delivery_data = json.load(file)\n \n         # Convert list of DeliveryData to DataFrame\n         df = pd.DataFrame([item.dict() for item in data])\n-        \n+\n         # Convert time columns to datetime\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n@@ -49,31 +42,19 @@\n \n         # Convert time columns to minutes since midnight for analysis and prediction\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        \n-        avg_preferred_time = df['preferred_time_minutes'].mean()\n-        avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-        if pd.isna(avg_preferred_time):\n-            avg_preferred_time = 0\n-        if pd.isna(avg_delivery_time):\n-            avg_delivery_time = 0\n+        # Group the data by location and find the optimal delivery time for each location\n+        location_groups = df.groupby(['location.city', 'location.region', 'location.postal_code'])\n+        optimal_delivery_times = {}\n \n-        analysis_result = {\n-            'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n-            'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n-        }\n-        \n-        # Make predictions using the trained model\n-        X = df[['preferred_time_minutes']]\n-        try:\n-            predictions = model.predict(X)\n-        except AttributeError:\n-            raise HTTPException(status_code=500, detail=\"Model does not have a predict method.\")\n-        \n-        # Prepare prediction results\n-        prediction_results = list(predictions)\n+        for group, group_df in location_groups:\n+            city, region, postal_code = group\n+            location_key = f\"{city}, {region} - {postal_code}\"\n+            preferred_times = group_df['preferred_time_minutes'].tolist()\n+            optimal_delivery_time = min(preferred_times)\n+            optimal_delivery_times[location_key] = optimal_delivery_time\n \n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n@@ -84,42 +65,18 @@\n         plt.title('Preferred Time vs Delivery Time')\n         plt.xlabel('Preferred Time (Minutes since Midnight)')\n         plt.ylabel('Delivery Time (Minutes since Midnight)')\n         plt.grid(True)\n-        \n+\n         buf = io.BytesIO()\n         plt.savefig(buf, format='png')\n         buf.seek(0)\n         img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n         plt.close()  # Close the plot to free memory\n-        \n-        return {\n-            'analysis_result': analysis_result,\n-            'visualization': f'data:image/png;base64,{img_base64}',\n-            'predictions': prediction_results\n-        }\n-    except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n \n-@app.post(\"/predict-delivery-time/\")\n-async def predict_delivery_time(data: DeliveryData):\n-    try:\n-        # Convert the input data to a DataFrame\n-        input_data = pd.DataFrame([data.dict()])\n-        input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n-        input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        \n-        # Make prediction\n-        prediction = model.predict(input_data[['preferred_time_minutes']])\n-        \n-        # Convert prediction to time format\n-        predicted_time = int(prediction[0])\n-        predicted_hours = predicted_time // 60\n-        predicted_minutes = predicted_time % 60\n-        \n         return {\n-            'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n+            'optimal_delivery_times': optimal_delivery_times,\n+            'visualization': f'data:image/png;base64,{img_base64}'\n         }\n     except Exception as e:\n         logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n+        raise HTTPException(status_code=500, detail=str(e))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725480288809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,82 +1,10 @@\n-from fastapi import FastAPI, HTTPException, APIRouter\n-from pydantic import BaseModel\n-import pandas as pd\n-import matplotlib.pyplot as plt\n-import io\n-import base64\n-from typing import List\n-import json\n+from fastapi import FastAPI\n+from app import process_data\n \n-# Set up logging\n-import logging\n-logging.basicConfig(level=logging.INFO)\n+app = FastAPI()\n \n-# Define the data model\n-class DeliveryData(BaseModel):\n-    recipient_id: str\n-    preferred_time: str  # Assuming HH:MM format\n-    delivery_date: str\n-    delivery_time: str   # Assuming HH:MM format\n-    location: dict\n-    day_of_week: str\n-    special_event: str\n+app.include_router(process_data)\n \n-process_data = APIRouter()\n-\n-@process_data.post(\"/process-data/\")\n-async def process_data_endpoint(data: List[DeliveryData]):\n-    try:\n-        # Load the JSON data\n-        with open('delivery.json', 'r') as file:\n-            delivery_data = json.load(file)\n-\n-        # Convert list of DeliveryData to DataFrame\n-        df = pd.DataFrame([item.dict() for item in data])\n-\n-        # Convert time columns to datetime\n-        try:\n-            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-        except ValueError:\n-            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n-\n-        # Convert time columns to minutes since midnight for analysis and prediction\n-        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-\n-        # Group the data by location and find the optimal delivery time for each location\n-        location_groups = df.groupby(['location.city', 'location.region', 'location.postal_code'])\n-        optimal_delivery_times = {}\n-\n-        for group, group_df in location_groups:\n-            city, region, postal_code = group\n-            location_key = f\"{city}, {region} - {postal_code}\"\n-            preferred_times = group_df['preferred_time_minutes'].tolist()\n-            optimal_delivery_time = min(preferred_times)\n-            optimal_delivery_times[location_key] = optimal_delivery_time\n-\n-        # Create and save visualization\n-        plt.figure(figsize=(10, 6))\n-        plt.scatter(\n-            df['preferred_time_minutes'],\n-            df['delivery_time_minutes'],\n-            alpha=0.5\n-        )\n-        plt.title('Preferred Time vs Delivery Time')\n-        plt.xlabel('Preferred Time (Minutes since Midnight)')\n-        plt.ylabel('Delivery Time (Minutes since Midnight)')\n-        plt.grid(True)\n-\n-        buf = io.BytesIO()\n-        plt.savefig(buf, format='png')\n-        buf.seek(0)\n-        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-        plt.close()  # Close the plot to free memory\n-\n-        return {\n-            'optimal_delivery_times': optimal_delivery_times,\n-            'visualization': f'data:image/png;base64,{img_base64}'\n\\ No newline at end of file\n-        }\n-    except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n+if __name__ == \"__main__\":\n+    import uvicorn\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725523907324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,32 @@\n from fastapi import FastAPI\n-from app import process_data\n+from fastapi.middleware.cors import CORSMiddleware\n+from app import process_data  # Ensure this is a valid import from app.py or another file\n \n app = FastAPI()\n \n+# CORS configuration\n+origins = [\n+    \"http://localhost:3000\",  # Your frontend URL\n\\ No newline at end of file\n+    \"http://127.0.0.1:3000\",\n+    # Add any other frontend URLs you are using\n+]\n+\n+app.add_middleware(\n+    CORSMiddleware,\n+    allow_origins=origins,\n+    allow_credentials=True,\n+    allow_methods=[\"*\"],\n+    allow_headers=[\"*\"],\n+)\n+\n+# Default route\n+@app.get(\"/\")\n+def read_root():\n+    return {\"Hello\": \"World\"}\n+\n+# Include the router\n app.include_router(process_data)\n \n if __name__ == \"__main__\":\n     import uvicorn\n-    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"
                },
                {
                    "date": 1725600753744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,32 +1,121 @@\n-from fastapi import FastAPI\n-from fastapi.middleware.cors import CORSMiddleware\n-from app import process_data  # Ensure this is a valid import from app.py or another file\n+from fastapi import FastAPI, HTTPException, APIRouter\n+from pydantic import BaseModel\n+import pandas as pd\n+import matplotlib.pyplot as plt\n+import io\n+import base64\n+from typing import List, Tuple\n+import json\n+from geopy.geocoders import Nominatim\n+from geopy.distance import geodesic  # To calculate distances between lat/lon coordinates\n \n+# Set up logging\n+import logging\n+logging.basicConfig(level=logging.INFO)\n+\n app = FastAPI()\n \n-# CORS configuration\n-origins = [\n-    \"http://localhost:3000\",  # Your frontend URL\n-    \"http://127.0.0.1:3000\",\n-    # Add any other frontend URLs you are using\n-]\n+# Define the data model for delivery data\n+class Location(BaseModel):\n+    address: str  # Real address string\n \n-app.add_middleware(\n-    CORSMiddleware,\n\\ No newline at end of file\n-    allow_origins=origins,\n-    allow_credentials=True,\n-    allow_methods=[\"*\"],\n-    allow_headers=[\"*\"],\n-)\n+class DeliveryData(BaseModel):\n+    recipient_id: str\n+    preferred_time: str  # Assuming HH:MM format\n+    delivery_date: str\n+    delivery_time: str   # Assuming HH:MM format\n+    location: Location  # Updated to use real addresses\n+    day_of_week: str\n+    special_event: str\n \n-# Default route\n-@app.get(\"/\")\n-def read_root():\n-    return {\"Hello\": \"World\"}\n+class CurrentLocation(BaseModel):\n+    address: str  # User's current address for finding nearest delivery location\n \n-# Include the router\n+process_data = APIRouter()\n+\n+# Function to get latitude and longitude from address\n+def get_lat_lon(address: str) -> Tuple[float, float]:\n+    geolocator = Nominatim(user_agent=\"geoapiExercises\")\n+    location = geolocator.geocode(address)\n+    if location:\n+        return location.latitude, location.longitude\n+    else:\n+        raise ValueError(f\"Could not find coordinates for address: {address}\")\n+\n+# Function to calculate nearest delivery location\n+def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> str:\n+    locations['distance'] = locations.apply(\n+        lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n+    )\n+    nearest_location = locations.loc[locations['distance'].idxmin()]\n+    return nearest_location['location_key'], nearest_location['distance']\n+\n+@process_data.post(\"/process-data/\")\n+async def process_data_endpoint(data: List[DeliveryData], current_location: CurrentLocation):\n+    try:\n+        # Load the JSON data\n+        with open('delivery.json', 'r') as file:\n+            delivery_data = json.load(file)\n+\n+        # Convert list of DeliveryData to DataFrame\n+        df = pd.DataFrame([item.dict() for item in data])\n+\n+        # Convert time columns to datetime\n+        try:\n+            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        except ValueError:\n+            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n+\n+        # Convert time columns to minutes since midnight for analysis and prediction\n+        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+\n+        # Geocode addresses to get latitude and longitude\n+        df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n+\n+        # Group the data by location and find the optimal delivery time for each location\n+        df['location_key'] = df.apply(lambda row: f\"{row['latitude']}, {row['longitude']}\", axis=1)\n+        location_groups = df.groupby('location_key')\n+        optimal_delivery_times = {}\n+\n+        for location_key, group_df in location_groups:\n+            preferred_times = group_df['preferred_time_minutes'].tolist()\n+            optimal_delivery_time = min(preferred_times)\n+            optimal_delivery_times[location_key] = optimal_delivery_time\n+\n+        # Find the nearest delivery location from the user's current location\n+        user_lat, user_lon = get_lat_lon(current_location.address)\n+        nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n+\n+        # Create and save visualization\n+        plt.figure(figsize=(10, 6))\n+        plt.scatter(\n+            df['preferred_time_minutes'],\n+            df['delivery_time_minutes'],\n+            alpha=0.5\n+        )\n+        plt.title('Preferred Time vs Delivery Time')\n+        plt.xlabel('Preferred Time (Minutes since Midnight)')\n+        plt.ylabel('Delivery Time (Minutes since Midnight)')\n+        plt.grid(True)\n+\n+        buf = io.BytesIO()\n+        plt.savefig(buf, format='png')\n+        buf.seek(0)\n+        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n+        plt.close()  # Close the plot to free memory\n+\n+        return {\n+            'optimal_delivery_times': optimal_delivery_times,\n+            'nearest_location': {\n+                'location': nearest_location,\n+                'distance_km': distance\n+            },\n+            'visualization': f'data:image/png;base64,{img_base64}'\n+        }\n+    except Exception as e:\n+        logging.error(f\"Exception occurred: {str(e)}\")\n+        raise HTTPException(status_code=500, detail=str(e))\n+\n app.include_router(process_data)\n-\n-if __name__ == \"__main__\":\n-    import uvicorn\n-    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"
                },
                {
                    "date": 1725601272929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,32 +6,34 @@\n import base64\n from typing import List, Tuple\n import json\n from geopy.geocoders import Nominatim\n-from geopy.distance import geodesic  # To calculate distances between lat/lon coordinates\n+from geopy.distance import geodesic\n \n-# Set up logging\n-import logging\n-logging.basicConfig(level=logging.INFO)\n-\n app = FastAPI()\n \n-# Define the data model for delivery data\n+# Define the data models\n class Location(BaseModel):\n-    address: str  # Real address string\n+    city: str\n+    region: str\n+    postal_code: str\n \n class DeliveryData(BaseModel):\n     recipient_id: str\n-    preferred_time: str  # Assuming HH:MM format\n+    preferred_time: str\n     delivery_date: str\n-    delivery_time: str   # Assuming HH:MM format\n-    location: Location  # Updated to use real addresses\n+    delivery_time: str\n+    location: Location\n     day_of_week: str\n     special_event: str\n \n class CurrentLocation(BaseModel):\n-    address: str  # User's current address for finding nearest delivery location\n+    address: str\n \n+class NearestLocationRequest(BaseModel):\n+    current_location: Location\n+    recipients: List[DeliveryData]\n+\n process_data = APIRouter()\n \n # Function to get latitude and longitude from address\n def get_lat_lon(address: str) -> Tuple[float, float]:\n@@ -52,30 +54,24 @@\n \n @process_data.post(\"/process-data/\")\n async def process_data_endpoint(data: List[DeliveryData], current_location: CurrentLocation):\n     try:\n-        # Load the JSON data\n         with open('delivery.json', 'r') as file:\n             delivery_data = json.load(file)\n \n-        # Convert list of DeliveryData to DataFrame\n         df = pd.DataFrame([item.dict() for item in data])\n \n-        # Convert time columns to datetime\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n         except ValueError:\n             raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n \n-        # Convert time columns to minutes since midnight for analysis and prediction\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n \n-        # Geocode addresses to get latitude and longitude\n         df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n \n-        # Group the data by location and find the optimal delivery time for each location\n         df['location_key'] = df.apply(lambda row: f\"{row['latitude']}, {row['longitude']}\", axis=1)\n         location_groups = df.groupby('location_key')\n         optimal_delivery_times = {}\n \n@@ -83,13 +79,11 @@\n             preferred_times = group_df['preferred_time_minutes'].tolist()\n             optimal_delivery_time = min(preferred_times)\n             optimal_delivery_times[location_key] = optimal_delivery_time\n \n-        # Find the nearest delivery location from the user's current location\n         user_lat, user_lon = get_lat_lon(current_location.address)\n         nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n \n-        # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n             df['preferred_time_minutes'],\n             df['delivery_time_minutes'],\n@@ -103,9 +97,9 @@\n         buf = io.BytesIO()\n         plt.savefig(buf, format='png')\n         buf.seek(0)\n         img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-        plt.close()  # Close the plot to free memory\n+        plt.close()\n \n         return {\n             'optimal_delivery_times': optimal_delivery_times,\n             'nearest_location': {\n@@ -117,5 +111,33 @@\n     except Exception as e:\n         logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n+@process_data.post(\"/nearest-location/\")\n+async def nearest_location(request: NearestLocationRequest):\n+    geolocator = Nominatim(user_agent=\"geoapiExercises\")\n+\n+    def get_coordinates(location: Location):\n+        location_str = f\"{location.city}, {location.region}, {location.postal_code}\"\n+        loc = geolocator.geocode(location_str)\n+        if loc:\n+            return (loc.latitude, loc.longitude)\n+        return None\n+\n+    current_coords = get_coordinates(request.current_location)\n+    if not current_coords:\n+        raise HTTPException(status_code=400, detail=\"Invalid current location\")\n+\n+    nearest_recipient = None\n+    min_distance = float('inf')\n+\n+    for recipient in request.recipients:\n+        recipient_coords = get_coordinates(recipient.location)\n+        if recipient_coords:\n+            distance = geodesic(current_coords, recipient_coords).kilometers\n+            if distance < min_distance:\n+                min_distance = distance\n+                nearest_recipient = recipient\n+\n+    return {\"nearest_recipient\": nearest_recipient, \"distance_km\": min_distance}\n+\n app.include_router(process_data)\n"
                },
                {
                    "date": 1725601351626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,11 +12,9 @@\n app = FastAPI()\n \n # Define the data models\n class Location(BaseModel):\n-    city: str\n-    region: str\n-    postal_code: str\n+    address: str\n \n class DeliveryData(BaseModel):\n     recipient_id: str\n     preferred_time: str\n@@ -116,9 +114,9 @@\n async def nearest_location(request: NearestLocationRequest):\n     geolocator = Nominatim(user_agent=\"geoapiExercises\")\n \n     def get_coordinates(location: Location):\n-        location_str = f\"{location.city}, {location.region}, {location.postal_code}\"\n+        location_str = location.address\n         loc = geolocator.geocode(location_str)\n         if loc:\n             return (loc.latitude, loc.longitude)\n         return None\n"
                },
                {
                    "date": 1725601970363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,12 @@\n \n class CurrentLocation(BaseModel):\n     address: str\n \n+class ProcessDataRequest(BaseModel):\n+    current_location: CurrentLocation\n+    data: List[DeliveryData]\n+\n class NearestLocationRequest(BaseModel):\n     current_location: Location\n     recipients: List[DeliveryData]\n \n@@ -50,38 +54,48 @@\n     nearest_location = locations.loc[locations['distance'].idxmin()]\n     return nearest_location['location_key'], nearest_location['distance']\n \n @process_data.post(\"/process-data/\")\n-async def process_data_endpoint(data: List[DeliveryData], current_location: CurrentLocation):\n+async def process_data_endpoint(request: ProcessDataRequest):\n     try:\n+        current_location = request.current_location\n+        data = request.data\n+        \n+        # Load data from a JSON file (as an example)\n         with open('delivery.json', 'r') as file:\n             delivery_data = json.load(file)\n \n         df = pd.DataFrame([item.dict() for item in data])\n \n+        # Parse times and ensure correct format\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n         except ValueError:\n             raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n \n+        # Convert preferred and delivery times to minutes\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n \n+        # Get latitude and longitude for each location\n         df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n \n         df['location_key'] = df.apply(lambda row: f\"{row['latitude']}, {row['longitude']}\", axis=1)\n         location_groups = df.groupby('location_key')\n         optimal_delivery_times = {}\n \n+        # Calculate the optimal delivery times for each location\n         for location_key, group_df in location_groups:\n             preferred_times = group_df['preferred_time_minutes'].tolist()\n             optimal_delivery_time = min(preferred_times)\n             optimal_delivery_times[location_key] = optimal_delivery_time\n \n+        # Calculate the nearest location to the user\n         user_lat, user_lon = get_lat_lon(current_location.address)\n         nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n \n+        # Generate the visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n             df['preferred_time_minutes'],\n             df['delivery_time_minutes'],\n@@ -91,8 +105,9 @@\n         plt.xlabel('Preferred Time (Minutes since Midnight)')\n         plt.ylabel('Delivery Time (Minutes since Midnight)')\n         plt.grid(True)\n \n+        # Save the plot to a buffer and encode as base64\n         buf = io.BytesIO()\n         plt.savefig(buf, format='png')\n         buf.seek(0)\n         img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n@@ -106,9 +121,8 @@\n             },\n             'visualization': f'data:image/png;base64,{img_base64}'\n         }\n     except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n @process_data.post(\"/nearest-location/\")\n async def nearest_location(request: NearestLocationRequest):\n@@ -120,15 +134,17 @@\n         if loc:\n             return (loc.latitude, loc.longitude)\n         return None\n \n+    # Get current location coordinates\n     current_coords = get_coordinates(request.current_location)\n     if not current_coords:\n         raise HTTPException(status_code=400, detail=\"Invalid current location\")\n \n     nearest_recipient = None\n     min_distance = float('inf')\n \n+    # Calculate nearest recipient based on coordinates\n     for recipient in request.recipients:\n         recipient_coords = get_coordinates(recipient.location)\n         if recipient_coords:\n             distance = geodesic(current_coords, recipient_coords).kilometers\n@@ -137,5 +153,6 @@\n                 nearest_recipient = recipient\n \n     return {\"nearest_recipient\": nearest_recipient, \"distance_km\": min_distance}\n \n+# Include the router in the FastAPI app\n app.include_router(process_data)\n"
                },
                {
                    "date": 1725602695245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,158 +1,10 @@\n-from fastapi import FastAPI, HTTPException, APIRouter\n-from pydantic import BaseModel\n-import pandas as pd\n-import matplotlib.pyplot as plt\n-import io\n-import base64\n-from typing import List, Tuple\n-import json\n-from geopy.geocoders import Nominatim\n-from geopy.distance import geodesic\n+from fastapi import FastAPI\n+from app import process_data\n \n app = FastAPI()\n \n-# Define the data models\n-class Location(BaseModel):\n-    address: str\n+app.include_router(process_data)\n \n-class DeliveryData(BaseModel):\n-    recipient_id: str\n-    preferred_time: str\n-    delivery_date: str\n-    delivery_time: str\n-    location: Location\n-    day_of_week: str\n-    special_event: str\n-\n-class CurrentLocation(BaseModel):\n-    address: str\n-\n-class ProcessDataRequest(BaseModel):\n-    current_location: CurrentLocation\n-    data: List[DeliveryData]\n-\n-class NearestLocationRequest(BaseModel):\n-    current_location: Location\n-    recipients: List[DeliveryData]\n-\n-process_data = APIRouter()\n-\n-# Function to get latitude and longitude from address\n-def get_lat_lon(address: str) -> Tuple[float, float]:\n-    geolocator = Nominatim(user_agent=\"geoapiExercises\")\n-    location = geolocator.geocode(address)\n-    if location:\n-        return location.latitude, location.longitude\n-    else:\n-        raise ValueError(f\"Could not find coordinates for address: {address}\")\n-\n-# Function to calculate nearest delivery location\n-def find_nearest_location(user_lat: float, user_lon: float, locations: pd.DataFrame) -> str:\n-    locations['distance'] = locations.apply(\n-        lambda row: geodesic((user_lat, user_lon), (row['latitude'], row['longitude'])).km, axis=1\n-    )\n-    nearest_location = locations.loc[locations['distance'].idxmin()]\n-    return nearest_location['location_key'], nearest_location['distance']\n-\n-@process_data.post(\"/process-data/\")\n-async def process_data_endpoint(request: ProcessDataRequest):\n-    try:\n-        current_location = request.current_location\n-        data = request.data\n-        \n-        # Load data from a JSON file (as an example)\n-        with open('delivery.json', 'r') as file:\n-            delivery_data = json.load(file)\n-\n-        df = pd.DataFrame([item.dict() for item in data])\n-\n-        # Parse times and ensure correct format\n-        try:\n-            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-        except ValueError:\n-            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n-\n-        # Convert preferred and delivery times to minutes\n-        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-\n-        # Get latitude and longitude for each location\n-        df['latitude'], df['longitude'] = zip(*df['location'].apply(lambda loc: get_lat_lon(loc['address'])))\n-\n-        df['location_key'] = df.apply(lambda row: f\"{row['latitude']}, {row['longitude']}\", axis=1)\n-        location_groups = df.groupby('location_key')\n-        optimal_delivery_times = {}\n-\n-        # Calculate the optimal delivery times for each location\n-        for location_key, group_df in location_groups:\n-            preferred_times = group_df['preferred_time_minutes'].tolist()\n-            optimal_delivery_time = min(preferred_times)\n-            optimal_delivery_times[location_key] = optimal_delivery_time\n-\n-        # Calculate the nearest location to the user\n-        user_lat, user_lon = get_lat_lon(current_location.address)\n-        nearest_location, distance = find_nearest_location(user_lat, user_lon, df)\n-\n-        # Generate the visualization\n-        plt.figure(figsize=(10, 6))\n-        plt.scatter(\n-            df['preferred_time_minutes'],\n-            df['delivery_time_minutes'],\n-            alpha=0.5\n-        )\n-        plt.title('Preferred Time vs Delivery Time')\n-        plt.xlabel('Preferred Time (Minutes since Midnight)')\n-        plt.ylabel('Delivery Time (Minutes since Midnight)')\n-        plt.grid(True)\n-\n-        # Save the plot to a buffer and encode as base64\n-        buf = io.BytesIO()\n-        plt.savefig(buf, format='png')\n-        buf.seek(0)\n-        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-        plt.close()\n-\n-        return {\n-            'optimal_delivery_times': optimal_delivery_times,\n-            'nearest_location': {\n-                'location': nearest_location,\n-                'distance_km': distance\n-            },\n-            'visualization': f'data:image/png;base64,{img_base64}'\n-        }\n-    except Exception as e:\n-        raise HTTPException(status_code=500, detail=str(e))\n-\n-@process_data.post(\"/nearest-location/\")\n-async def nearest_location(request: NearestLocationRequest):\n-    geolocator = Nominatim(user_agent=\"geoapiExercises\")\n-\n-    def get_coordinates(location: Location):\n-        location_str = location.address\n-        loc = geolocator.geocode(location_str)\n-        if loc:\n-            return (loc.latitude, loc.longitude)\n-        return None\n-\n-    # Get current location coordinates\n-    current_coords = get_coordinates(request.current_location)\n-    if not current_coords:\n-        raise HTTPException(status_code=400, detail=\"Invalid current location\")\n-\n-    nearest_recipient = None\n-    min_distance = float('inf')\n-\n-    # Calculate nearest recipient based on coordinates\n-    for recipient in request.recipients:\n-        recipient_coords = get_coordinates(recipient.location)\n-        if recipient_coords:\n-            distance = geodesic(current_coords, recipient_coords).kilometers\n-            if distance < min_distance:\n-                min_distance = distance\n-                nearest_recipient = recipient\n-\n-    return {\"nearest_recipient\": nearest_recipient, \"distance_km\": min_distance}\n-\n-# Include the router in the FastAPI app\n-app.include_router(process_data)\n+if __name__ == \"__main__\":\n+    import uvicorn\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725603019626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,12 @@\n from fastapi import FastAPI\n-from app import process_data\n+from app import process_data  # Import the router from app.py\n \n app = FastAPI()\n \n+# Include the process_data router\n app.include_router(process_data)\n \n+# Run the application\n\\ No newline at end of file\n if __name__ == \"__main__\":\n     import uvicorn\n-    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"
                },
                {
                    "date": 1725603243836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,10 @@\n from fastapi import FastAPI\n-from app import process_data  # Import the router from app.py\n+from app import process_data\n \n app = FastAPI()\n \n-# Include the process_data router\n app.include_router(process_data)\n \n-# Run the application\n if __name__ == \"__main__\":\n     import uvicorn\n     uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725612491077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,21 @@\n-from fastapi import FastAPI\n+# In your main.py file\n+\n+from fastapi.middleware.cors import CORSMiddleware\n from app import process_data\n \n app = FastAPI()\n \n+# Allowing CORS\n+app.add_middleware(\n\\ No newline at end of file\n+    CORSMiddleware,\n+    allow_origins=[\"*\"],  # You can specify your front-end domain instead of \"*\"\n+    allow_credentials=True,\n+    allow_methods=[\"*\"],  # This allows all methods (GET, POST, OPTIONS, etc.)\n+    allow_headers=[\"*\"],  # This allows all headers\n+)\n+\n app.include_router(process_data)\n \n if __name__ == \"__main__\":\n     import uvicorn\n-    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"
                },
                {
                    "date": 1725612548185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n # In your main.py file\n+from fastapi import FastAPI\n \n from fastapi.middleware.cors import CORSMiddleware\n from app import process_data\n \n@@ -17,5 +18,5 @@\n app.include_router(process_data)\n \n if __name__ == \"__main__\":\n     import uvicorn\n-    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\\ No newline at end of file\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n"
                }
            ],
            "date": 1725460824308,
            "name": "Commit-0",
            "content": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport json\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport io\nimport base64\n\napp = FastAPI()\n\n# Define the data model\nclass DeliveryData(BaseModel):\n    preferred_time: str\n    delivery_time: str\n\n@app.post(\"/process-data/\")\nasync def process_data(data: list[DeliveryData]):\n    df = pd.json_normalize([item.dict() for item in data])\n    \n    # Convert time columns to datetime\n    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n    \n    # Analyze Data\n    avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n    avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n\n    if pd.isna(avg_preferred_time):\n        avg_preferred_time = 0\n    if pd.isna(avg_delivery_time):\n        avg_delivery_time = 0\n\n    analysis_result = {\n        'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n        'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n    }\n    \n    # Create and save visualization\n    plt.figure(figsize=(10, 6))\n    plt.scatter(\n        df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n        df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n        alpha=0.5\n    )\n    plt.title('Preferred Time vs Delivery Time')\n    plt.xlabel('Preferred Time (Minutes since Midnight)')\n    plt.ylabel('Delivery Time (Minutes since Midnight)')\n    plt.grid(True)\n    \n    buf = io.BytesIO()\n    plt.savefig(buf, format='png')\n    buf.seek(0)\n    img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n    \n    return {\n        'analysis_result': analysis_result,\n        'visualization': f'data:image/png;base64,{img_base64}'\n    }\n"
        }
    ]
}