{
    "sourceFile": "main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1725460824308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725461518949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n from fastapi import FastAPI, HTTPException\n from pydantic import BaseModel\n-import json\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n+from typing import List\n \n app = FastAPI()\n \n # Define the data model\n@@ -13,46 +13,51 @@\n     preferred_time: str\n     delivery_time: str\n \n @app.post(\"/process-data/\")\n-async def process_data(data: list[DeliveryData]):\n-    df = pd.json_normalize([item.dict() for item in data])\n-    \n-    # Convert time columns to datetime\n-    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-    \n-    # Analyze Data\n-    avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n-    avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+async def process_data(data: List[DeliveryData]):\n+    try:\n+        # Convert list of DeliveryData to DataFrame\n+        df = pd.json_normalize([item.dict() for item in data])\n+        \n+        # Convert time columns to datetime\n+        df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+        df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        \n+        # Analyze Data\n+        avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+        avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n \n-    if pd.isna(avg_preferred_time):\n-        avg_preferred_time = 0\n-    if pd.isna(avg_delivery_time):\n-        avg_delivery_time = 0\n+        if pd.isna(avg_preferred_time):\n+            avg_preferred_time = 0\n+        if pd.isna(avg_delivery_time):\n+            avg_delivery_time = 0\n \n-    analysis_result = {\n-        'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n-        'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n-    }\n-    \n-    # Create and save visualization\n-    plt.figure(figsize=(10, 6))\n-    plt.scatter(\n-        df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n-        df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n-        alpha=0.5\n-    )\n-    plt.title('Preferred Time vs Delivery Time')\n-    plt.xlabel('Preferred Time (Minutes since Midnight)')\n-    plt.ylabel('Delivery Time (Minutes since Midnight)')\n-    plt.grid(True)\n-    \n-    buf = io.BytesIO()\n-    plt.savefig(buf, format='png')\n-    buf.seek(0)\n-    img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-    \n-    return {\n-        'analysis_result': analysis_result,\n-        'visualization': f'data:image/png;base64,{img_base64}'\n-    }\n+        analysis_result = {\n+            'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n+            'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n+        }\n+        \n+        # Create and save visualization\n+        plt.figure(figsize=(10, 6))\n+        plt.scatter(\n+            df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n+            df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n+            alpha=0.5\n+        )\n+        plt.title('Preferred Time vs Delivery Time')\n+        plt.xlabel('Preferred Time (Minutes since Midnight)')\n+        plt.ylabel('Delivery Time (Minutes since Midnight)')\n+        plt.grid(True)\n+        \n+        buf = io.BytesIO()\n+        plt.savefig(buf, format='png')\n+        buf.seek(0)\n+        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n+        plt.close()  # Close the plot to free memory\n+        \n+        return {\n+            'analysis_result': analysis_result,\n+            'visualization': f'data:image/png;base64,{img_base64}'\n+        }\n+    except Exception as e:\n+        raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725462088943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,18 +15,31 @@\n \n @app.post(\"/process-data/\")\n async def process_data(data: List[DeliveryData]):\n     try:\n+        if not data:\n+            raise HTTPException(status_code=400, detail=\"No data provided\")\n+\n         # Convert list of DeliveryData to DataFrame\n-        df = pd.json_normalize([item.dict() for item in data])\n+        df = pd.DataFrame([item.dict() for item in data])\n         \n+        # Check if required columns are present\n+        if 'preferred_time' not in df.columns or 'delivery_time' not in df.columns:\n+            raise HTTPException(status_code=400, detail=\"Missing required columns\")\n+\n         # Convert time columns to datetime\n-        df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-        df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        try:\n+            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        except ValueError:\n+            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n+\n+        # Analyze Data\n+        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n         \n-        # Analyze Data\n-        avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n-        avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+        avg_preferred_time = df['preferred_time_minutes'].mean()\n+        avg_delivery_time = df['delivery_time_minutes'].mean()\n \n         if pd.isna(avg_preferred_time):\n             avg_preferred_time = 0\n         if pd.isna(avg_delivery_time):\n@@ -39,10 +52,10 @@\n         \n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n-            df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n-            df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n+            df['preferred_time_minutes'],\n+            df['delivery_time_minutes'],\n             alpha=0.5\n         )\n         plt.title('Preferred Time vs Delivery Time')\n         plt.xlabel('Preferred Time (Minutes since Midnight)')\n"
                },
                {
                    "date": 1725470510543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,12 +3,17 @@\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n+import pickle\n from typing import List\n \n app = FastAPI()\n \n+# Load the trained model\n+with open('trained_model.pkl', 'rb') as f:\n+    model = pickle.load(f)\n+\n # Define the data model\n class DeliveryData(BaseModel):\n     preferred_time: str\n     delivery_time: str\n@@ -32,9 +37,9 @@\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n         except ValueError:\n             raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n \n-        # Analyze Data\n+        # Convert time columns to minutes since midnight for analysis and prediction\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n@@ -49,8 +54,15 @@\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n         }\n         \n+        # Make predictions using the trained model\n+        X = df[['preferred_time_minutes']]\n+        predictions = model.predict(X)\n+        \n+        # Prepare prediction results\n+        prediction_results = list(predictions)\n+\n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n             df['preferred_time_minutes'],\n@@ -69,8 +81,9 @@\n         plt.close()  # Close the plot to free memory\n         \n         return {\n             'analysis_result': analysis_result,\n-            'visualization': f'data:image/png;base64,{img_base64}'\n+            'visualization': f'data:image/png;base64,{img_base64}',\n+            'predictions': prediction_results\n         }\n     except Exception as e:\n         raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725470849655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,20 +4,25 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n-from typing import List\n+from typing import List, Dict, Any\n \n app = FastAPI()\n \n # Load the trained model\n-with open('trained_model.pkl', 'rb') as f:\n-    model = pickle.load(f)\n+try:\n+    with open('trained_model.pkl', 'rb') as f:\n+        model = pickle.load(f)\n+except FileNotFoundError:\n+    raise RuntimeError(\"Trained model file not found.\")\n+except Exception as e:\n+    raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n-    preferred_time: str\n-    delivery_time: str\n+    preferred_time: str  # Assuming HH:MM format\n+    delivery_time: str   # Assuming HH:MM format\n \n @app.post(\"/process-data/\")\n async def process_data(data: List[DeliveryData]):\n     try:\n@@ -26,12 +31,8 @@\n \n         # Convert list of DeliveryData to DataFrame\n         df = pd.DataFrame([item.dict() for item in data])\n         \n-        # Check if required columns are present\n-        if 'preferred_time' not in df.columns or 'delivery_time' not in df.columns:\n-            raise HTTPException(status_code=400, detail=\"Missing required columns\")\n-\n         # Convert time columns to datetime\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n"
                },
                {
                    "date": 1725471092691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n-from typing import List, Dict, Any\n+from typing import List\n \n app = FastAPI()\n \n # Load the trained model\n"
                },
                {
                    "date": 1725473162835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,4 +87,26 @@\n             'predictions': prediction_results\n         }\n     except Exception as e:\n         raise HTTPException(status_code=500, detail=str(e))\n+\n+@app.post(\"/predict-delivery-time/\")\n+async def predict_delivery_time(data: DeliveryData):\n+    try:\n+        # Convert the input data to a DataFrame\n+        input_data = pd.DataFrame([data.dict()])\n+        input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n+        input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        \n+        # Make prediction\n+        prediction = model.predict(input_data[['preferred_time_minutes']])\n+        \n+        # Convert prediction to time format\n+        predicted_time = int(prediction[0])\n+        predicted_hours = predicted_time // 60\n+        predicted_minutes = predicted_time % 60\n+        \n+        return {\n+            'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n+        }\n+    except Exception as e:\n+        raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725475826784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,18 +5,25 @@\n import io\n import base64\n import pickle\n from typing import List\n+import logging\n \n app = FastAPI()\n \n+# Configure logging\n+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n+\n # Load the trained model\n try:\n     with open('trained_model.pkl', 'rb') as f:\n         model = pickle.load(f)\n+    logging.info(\"Trained model loaded successfully.\")\n except FileNotFoundError:\n+    logging.error(\"Trained model file not found.\")\n     raise RuntimeError(\"Trained model file not found.\")\n except Exception as e:\n+    logging.error(f\"Error loading model: {str(e)}\")\n     raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n@@ -45,12 +52,11 @@\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n         avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-        if pd.isna(avg_preferred_time):\n-            avg_preferred_time = 0\n-        if pd.isna(avg_delivery_time):\n-            avg_delivery_time = 0\n+        # Handle NaN values\n+        avg_preferred_time = avg_preferred_time if not pd.isna(avg_preferred_time) else 0\n+        avg_delivery_time = avg_delivery_time if not pd.isna(avg_delivery_time) else 0\n \n         analysis_result = {\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n@@ -86,8 +92,9 @@\n             'visualization': f'data:image/png;base64,{img_base64}',\n             'predictions': prediction_results\n         }\n     except Exception as e:\n+        logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n @app.post(\"/predict-delivery-time/\")\n async def predict_delivery_time(data: DeliveryData):\n@@ -108,5 +115,6 @@\n         return {\n             'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n         }\n     except Exception as e:\n+        logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725477034619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,21 +4,22 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n+import logging\n from typing import List\n-import logging\n \n+# Set up logging\n+logging.basicConfig(level=logging.INFO)\n+\n app = FastAPI()\n \n-# Configure logging\n-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n-\n # Load the trained model\n try:\n     with open('trained_model.pkl', 'rb') as f:\n         model = pickle.load(f)\n     logging.info(\"Trained model loaded successfully.\")\n+    logging.info(f\"Model type: {type(model)}\")  # Debugging line to check model type\n except FileNotFoundError:\n     logging.error(\"Trained model file not found.\")\n     raise RuntimeError(\"Trained model file not found.\")\n except Exception as e:\n@@ -52,20 +53,24 @@\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n         avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-        # Handle NaN values\n-        avg_preferred_time = avg_preferred_time if not pd.isna(avg_preferred_time) else 0\n-        avg_delivery_time = avg_delivery_time if not pd.isna(avg_delivery_time) else 0\n+        if pd.isna(avg_preferred_time):\n+            avg_preferred_time = 0\n+        if pd.isna(avg_delivery_time):\n+            avg_delivery_time = 0\n \n         analysis_result = {\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n         }\n         \n         # Make predictions using the trained model\n         X = df[['preferred_time_minutes']]\n-        predictions = model.predict(X)\n+        try:\n+            predictions = model.predict(X)\n+        except AttributeError:\n+            raise HTTPException(status_code=500, detail=\"Model does not have a predict method.\")\n         \n         # Prepare prediction results\n         prediction_results = list(predictions)\n \n"
                },
                {
                    "date": 1725480271472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,46 +1,39 @@\n-from fastapi import FastAPI, HTTPException\n+from fastapi import FastAPI, HTTPException, APIRouter\n from pydantic import BaseModel\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n-import pickle\n-import logging\n from typing import List\n+import json\n \n # Set up logging\n+import logging\n logging.basicConfig(level=logging.INFO)\n \n-app = FastAPI()\n-\n-# Load the trained model\n-try:\n-    with open('trained_model.pkl', 'rb') as f:\n-        model = pickle.load(f)\n-    logging.info(\"Trained model loaded successfully.\")\n-    logging.info(f\"Model type: {type(model)}\")  # Debugging line to check model type\n-except FileNotFoundError:\n-    logging.error(\"Trained model file not found.\")\n-    raise RuntimeError(\"Trained model file not found.\")\n-except Exception as e:\n-    logging.error(f\"Error loading model: {str(e)}\")\n-    raise RuntimeError(f\"Error loading model: {str(e)}\")\n-\n # Define the data model\n class DeliveryData(BaseModel):\n+    recipient_id: str\n     preferred_time: str  # Assuming HH:MM format\n+    delivery_date: str\n     delivery_time: str   # Assuming HH:MM format\n+    location: dict\n+    day_of_week: str\n+    special_event: str\n \n-@app.post(\"/process-data/\")\n-async def process_data(data: List[DeliveryData]):\n+process_data = APIRouter()\n+\n+@process_data.post(\"/process-data/\")\n+async def process_data_endpoint(data: List[DeliveryData]):\n     try:\n-        if not data:\n-            raise HTTPException(status_code=400, detail=\"No data provided\")\n+        # Load the JSON data\n+        with open('delivery.json', 'r') as file:\n+            delivery_data = json.load(file)\n \n         # Convert list of DeliveryData to DataFrame\n         df = pd.DataFrame([item.dict() for item in data])\n-        \n+\n         # Convert time columns to datetime\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n@@ -49,31 +42,19 @@\n \n         # Convert time columns to minutes since midnight for analysis and prediction\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        \n-        avg_preferred_time = df['preferred_time_minutes'].mean()\n-        avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-        if pd.isna(avg_preferred_time):\n-            avg_preferred_time = 0\n-        if pd.isna(avg_delivery_time):\n-            avg_delivery_time = 0\n+        # Group the data by location and find the optimal delivery time for each location\n+        location_groups = df.groupby(['location.city', 'location.region', 'location.postal_code'])\n+        optimal_delivery_times = {}\n \n-        analysis_result = {\n-            'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n-            'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n-        }\n-        \n-        # Make predictions using the trained model\n-        X = df[['preferred_time_minutes']]\n-        try:\n-            predictions = model.predict(X)\n-        except AttributeError:\n-            raise HTTPException(status_code=500, detail=\"Model does not have a predict method.\")\n-        \n-        # Prepare prediction results\n-        prediction_results = list(predictions)\n+        for group, group_df in location_groups:\n+            city, region, postal_code = group\n+            location_key = f\"{city}, {region} - {postal_code}\"\n+            preferred_times = group_df['preferred_time_minutes'].tolist()\n+            optimal_delivery_time = min(preferred_times)\n+            optimal_delivery_times[location_key] = optimal_delivery_time\n \n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n@@ -84,42 +65,18 @@\n         plt.title('Preferred Time vs Delivery Time')\n         plt.xlabel('Preferred Time (Minutes since Midnight)')\n         plt.ylabel('Delivery Time (Minutes since Midnight)')\n         plt.grid(True)\n-        \n+\n         buf = io.BytesIO()\n         plt.savefig(buf, format='png')\n         buf.seek(0)\n         img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n         plt.close()  # Close the plot to free memory\n-        \n-        return {\n-            'analysis_result': analysis_result,\n-            'visualization': f'data:image/png;base64,{img_base64}',\n-            'predictions': prediction_results\n-        }\n-    except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n \n-@app.post(\"/predict-delivery-time/\")\n-async def predict_delivery_time(data: DeliveryData):\n-    try:\n-        # Convert the input data to a DataFrame\n-        input_data = pd.DataFrame([data.dict()])\n-        input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n-        input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        \n-        # Make prediction\n-        prediction = model.predict(input_data[['preferred_time_minutes']])\n-        \n-        # Convert prediction to time format\n-        predicted_time = int(prediction[0])\n-        predicted_hours = predicted_time // 60\n-        predicted_minutes = predicted_time % 60\n-        \n         return {\n-            'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n+            'optimal_delivery_times': optimal_delivery_times,\n+            'visualization': f'data:image/png;base64,{img_base64}'\n         }\n     except Exception as e:\n         logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n+        raise HTTPException(status_code=500, detail=str(e))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725480288809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,82 +1,10 @@\n-from fastapi import FastAPI, HTTPException, APIRouter\n-from pydantic import BaseModel\n-import pandas as pd\n-import matplotlib.pyplot as plt\n-import io\n-import base64\n-from typing import List\n-import json\n+from fastapi import FastAPI\n+from app import process_data\n \n-# Set up logging\n-import logging\n-logging.basicConfig(level=logging.INFO)\n+app = FastAPI()\n \n-# Define the data model\n-class DeliveryData(BaseModel):\n-    recipient_id: str\n-    preferred_time: str  # Assuming HH:MM format\n-    delivery_date: str\n-    delivery_time: str   # Assuming HH:MM format\n-    location: dict\n-    day_of_week: str\n-    special_event: str\n+app.include_router(process_data)\n \n-process_data = APIRouter()\n-\n-@process_data.post(\"/process-data/\")\n-async def process_data_endpoint(data: List[DeliveryData]):\n-    try:\n-        # Load the JSON data\n-        with open('delivery.json', 'r') as file:\n-            delivery_data = json.load(file)\n-\n-        # Convert list of DeliveryData to DataFrame\n-        df = pd.DataFrame([item.dict() for item in data])\n-\n-        # Convert time columns to datetime\n-        try:\n-            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-        except ValueError:\n-            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n-\n-        # Convert time columns to minutes since midnight for analysis and prediction\n-        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-\n-        # Group the data by location and find the optimal delivery time for each location\n-        location_groups = df.groupby(['location.city', 'location.region', 'location.postal_code'])\n-        optimal_delivery_times = {}\n-\n-        for group, group_df in location_groups:\n-            city, region, postal_code = group\n-            location_key = f\"{city}, {region} - {postal_code}\"\n-            preferred_times = group_df['preferred_time_minutes'].tolist()\n-            optimal_delivery_time = min(preferred_times)\n-            optimal_delivery_times[location_key] = optimal_delivery_time\n-\n-        # Create and save visualization\n-        plt.figure(figsize=(10, 6))\n-        plt.scatter(\n-            df['preferred_time_minutes'],\n-            df['delivery_time_minutes'],\n-            alpha=0.5\n-        )\n-        plt.title('Preferred Time vs Delivery Time')\n-        plt.xlabel('Preferred Time (Minutes since Midnight)')\n-        plt.ylabel('Delivery Time (Minutes since Midnight)')\n-        plt.grid(True)\n-\n-        buf = io.BytesIO()\n-        plt.savefig(buf, format='png')\n-        buf.seek(0)\n-        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-        plt.close()  # Close the plot to free memory\n-\n-        return {\n-            'optimal_delivery_times': optimal_delivery_times,\n-            'visualization': f'data:image/png;base64,{img_base64}'\n\\ No newline at end of file\n-        }\n-    except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n+if __name__ == \"__main__\":\n+    import uvicorn\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1725460824308,
            "name": "Commit-0",
            "content": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport json\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport io\nimport base64\n\napp = FastAPI()\n\n# Define the data model\nclass DeliveryData(BaseModel):\n    preferred_time: str\n    delivery_time: str\n\n@app.post(\"/process-data/\")\nasync def process_data(data: list[DeliveryData]):\n    df = pd.json_normalize([item.dict() for item in data])\n    \n    # Convert time columns to datetime\n    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n    \n    # Analyze Data\n    avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n    avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n\n    if pd.isna(avg_preferred_time):\n        avg_preferred_time = 0\n    if pd.isna(avg_delivery_time):\n        avg_delivery_time = 0\n\n    analysis_result = {\n        'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n        'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n    }\n    \n    # Create and save visualization\n    plt.figure(figsize=(10, 6))\n    plt.scatter(\n        df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n        df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n        alpha=0.5\n    )\n    plt.title('Preferred Time vs Delivery Time')\n    plt.xlabel('Preferred Time (Minutes since Midnight)')\n    plt.ylabel('Delivery Time (Minutes since Midnight)')\n    plt.grid(True)\n    \n    buf = io.BytesIO()\n    plt.savefig(buf, format='png')\n    buf.seek(0)\n    img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n    \n    return {\n        'analysis_result': analysis_result,\n        'visualization': f'data:image/png;base64,{img_base64}'\n    }\n"
        }
    ]
}