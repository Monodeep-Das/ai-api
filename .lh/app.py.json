{
    "sourceFile": "app.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1725456327762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1725459508874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,55 @@\n-v\n\\ No newline at end of file\n+import json\n+import pandas as pd\n+import matplotlib.pyplot as plt\n+\n+def load_data(file_path):\n+    \"\"\"Load JSON data from a file.\"\"\"\n+    with open(file_path, 'r') as file:\n+        data = json.load(file)\n+    return data\n+\n+def process_data(data):\n+    \"\"\"Convert JSON data to a DataFrame and perform basic processing.\"\"\"\n+    df = pd.json_normalize(data)\n+    \n+    # Convert time columns to datetime\n+    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+    \n+    return df\n+\n+def analyze_data(df):\n+    \"\"\"Analyze the DataFrame and print results.\"\"\"\n+    avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+    avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n+    \n+    print(f'Average preferred time: {avg_preferred_time // 60}:{avg_preferred_time % 60}')\n+    print(f'Average delivery time: {avg_delivery_time // 60}:{avg_delivery_time % 60}')\n+    \n+def visualize_data(df):\n+    \"\"\"Create and show visualizations from the DataFrame.\"\"\"\n+    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+    plt.hist(df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute), bins=24, edgecolor='k')\n+    plt.title('Distribution of Delivery Times')\n+    plt.xlabel('Minutes since Midnight')\n+    plt.ylabel('Frequency')\n+    plt.show()\n+\n+def export_data(df, output_file):\n+    \"\"\"Export DataFrame to a CSV file.\"\"\"\n+    df.to_csv(output_file, index=False)\n+\n+def main():\n+    # Paths\n+    json_file = 'delivery.json'\n+    csv_file = 'processed_delivery_data.csv'\n+\n+    # Load, process, analyze, and visualize data\n+    data = load_data(json_file)\n+    df = process_data(data)\n+    analyze_data(df)\n+    visualize_data(df)\n+    export_data(df, csv_file)\n+\n+if __name__ == '__main__':\n+    main()\n"
                },
                {
                    "date": 1725460023476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,26 +11,27 @@\n def process_data(data):\n     \"\"\"Convert JSON data to a DataFrame and perform basic processing.\"\"\"\n     df = pd.json_normalize(data)\n     \n-    # Convert time columns to datetime\n-    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+    # Convert time columns to datetime, handle both HH:MM and HH:MM:SS formats\n+    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M:%S', errors='coerce').dt.time\n+    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M:%S', errors='coerce').dt.time\n     \n     return df\n \n def analyze_data(df):\n     \"\"\"Analyze the DataFrame and print results.\"\"\"\n     avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n     avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n     \n-    print(f'Average preferred time: {avg_preferred_time // 60}:{avg_preferred_time % 60}')\n-    print(f'Average delivery time: {avg_delivery_time // 60}:{avg_delivery_time % 60}')\n-    \n+    print(f'Average preferred time: {int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}')\n+    print(f'Average delivery time: {int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}')\n+\n def visualize_data(df):\n     \"\"\"Create and show visualizations from the DataFrame.\"\"\"\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-    plt.hist(df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute), bins=24, edgecolor='k')\n+    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+    \n+    plt.hist(df['delivery_time_minutes'], bins=24, edgecolor='k')\n     plt.title('Distribution of Delivery Times')\n     plt.xlabel('Minutes since Midnight')\n     plt.ylabel('Frequency')\n     plt.show()\n"
                },
                {
                    "date": 1725460118284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,27 +11,36 @@\n def process_data(data):\n     \"\"\"Convert JSON data to a DataFrame and perform basic processing.\"\"\"\n     df = pd.json_normalize(data)\n     \n-    # Convert time columns to datetime, handle both HH:MM and HH:MM:SS formats\n-    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M:%S', errors='coerce').dt.time\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M:%S', errors='coerce').dt.time\n+    # Convert time columns to datetime\n+    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n     \n     return df\n \n def analyze_data(df):\n     \"\"\"Analyze the DataFrame and print results.\"\"\"\n+    # Ensure no NaN values are present in the 'preferred_time' and 'delivery_time' columns\n+    df = df.dropna(subset=['preferred_time', 'delivery_time'])\n+    \n+    # Calculate average preferred and delivery times\n     avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n     avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n     \n+    # Handle cases where averages might be NaN\n+    if pd.isna(avg_preferred_time):\n+        avg_preferred_time = 0\n+    if pd.isna(avg_delivery_time):\n+        avg_delivery_time = 0\n+\n     print(f'Average preferred time: {int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}')\n     print(f'Average delivery time: {int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}')\n \n def visualize_data(df):\n     \"\"\"Create and show visualizations from the DataFrame.\"\"\"\n-    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-    \n-    plt.hist(df['delivery_time_minutes'], bins=24, edgecolor='k')\n+    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+    plt.hist(df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute), bins=24, edgecolor='k')\n     plt.title('Distribution of Delivery Times')\n     plt.xlabel('Minutes since Midnight')\n     plt.ylabel('Frequency')\n     plt.show()\n"
                },
                {
                    "date": 1725460197878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,10 +37,12 @@\n     print(f'Average delivery time: {int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}')\n \n def visualize_data(df):\n     \"\"\"Create and show visualizations from the DataFrame.\"\"\"\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-    plt.hist(df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute), bins=24, edgecolor='k')\n+    # Convert times to minutes since midnight for plotting\n+    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+    \n+    plt.hist(df['delivery_time_minutes'], bins=24, edgecolor='k')\n     plt.title('Distribution of Delivery Times')\n     plt.xlabel('Minutes since Midnight')\n     plt.ylabel('Frequency')\n     plt.show()\n"
                },
                {
                    "date": 1725460797969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,10 @@\n import json\n import pandas as pd\n import matplotlib.pyplot as plt\n+from sklearn.linear_model import LinearRegression\n+from sklearn.model_selection import train_test_split\n+from sklearn.metrics import mean_squared_error\n \n def load_data(file_path):\n     \"\"\"Load JSON data from a file.\"\"\"\n     with open(file_path, 'r') as file:\n@@ -46,8 +49,54 @@\n     plt.xlabel('Minutes since Midnight')\n     plt.ylabel('Frequency')\n     plt.show()\n \n+def visualize_comparison(df):\n+    \"\"\"Compare preferred and delivery times in a scatter plot.\"\"\"\n+    plt.figure(figsize=(10, 6))\n+    plt.scatter(\n+        df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n+        df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n+        alpha=0.5\n+    )\n+    plt.title('Preferred Time vs Delivery Time')\n+    plt.xlabel('Preferred Time (Minutes since Midnight)')\n+    plt.ylabel('Delivery Time (Minutes since Midnight)')\n+    plt.grid(True)\n+    plt.show()\n+\n+def detailed_analysis(df):\n+    \"\"\"Perform detailed statistical analysis on the DataFrame.\"\"\"\n+    df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+    \n+    mean_preferred_time = df['preferred_time_minutes'].mean()\n+    std_preferred_time = df['preferred_time_minutes'].std()\n+    mean_delivery_time = df['delivery_time_minutes'].mean()\n+    std_delivery_time = df['delivery_time_minutes'].std()\n+    \n+    print(f'Mean Preferred Time: {mean_preferred_time // 60}:{mean_preferred_time % 60:02d} ± {std_preferred_time:.1f} minutes')\n+    print(f'Mean Delivery Time: {mean_delivery_time // 60}:{mean_delivery_time % 60:02d} ± {std_delivery_time:.1f} minutes')\n+\n+def build_model(df):\n+    \"\"\"Build and evaluate a simple linear regression model.\"\"\"\n+    df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+\n+    X = df[['preferred_time_minutes']]\n+    y = df['delivery_time_minutes']\n+\n+    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n+    \n+    model = LinearRegression()\n+    model.fit(X_train, y_train)\n+    \n+    y_pred = model.predict(X_test)\n+    mse = mean_squared_error(y_test, y_pred)\n+    \n+    print(f'Mean Squared Error: {mse:.2f}')\n+    return model\n+\n def export_data(df, output_file):\n     \"\"\"Export DataFrame to a CSV file.\"\"\"\n     df.to_csv(output_file, index=False)\n \n@@ -60,8 +109,11 @@\n     data = load_data(json_file)\n     df = process_data(data)\n     analyze_data(df)\n     visualize_data(df)\n+    visualize_comparison(df)  # New visualization\n+    detailed_analysis(df)     # Detailed analysis\n+    model = build_model(df)   # Model building\n     export_data(df, csv_file)\n \n if __name__ == '__main__':\n     main()\n"
                },
                {
                    "date": 1725470608994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,119 +1,99 @@\n-import json\n+from fastapi import FastAPI, HTTPException\n+from pydantic import BaseModel, constr\n import pandas as pd\n import matplotlib.pyplot as plt\n-from sklearn.linear_model import LinearRegression\n-from sklearn.model_selection import train_test_split\n-from sklearn.metrics import mean_squared_error\n+import io\n+import base64\n+from typing import List\n+import pickle\n \n-def load_data(file_path):\n-    \"\"\"Load JSON data from a file.\"\"\"\n-    with open(file_path, 'r') as file:\n-        data = json.load(file)\n-    return data\n+app = FastAPI()\n \n-def process_data(data):\n-    \"\"\"Convert JSON data to a DataFrame and perform basic processing.\"\"\"\n-    df = pd.json_normalize(data)\n-    \n-    # Convert time columns to datetime\n-    df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-    df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-    \n-    return df\n+# Load the trained model\n+try:\n+    with open('trained_model.pkl', 'rb') as model_file:\n+        model = pickle.load(model_file)\n+except FileNotFoundError:\n+    raise RuntimeError(\"Trained model file not found.\")\n+except Exception as e:\n+    raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n-def analyze_data(df):\n-    \"\"\"Analyze the DataFrame and print results.\"\"\"\n-    # Ensure no NaN values are present in the 'preferred_time' and 'delivery_time' columns\n-    df = df.dropna(subset=['preferred_time', 'delivery_time'])\n-    \n-    # Calculate average preferred and delivery times\n-    avg_preferred_time = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n-    avg_delivery_time = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute).mean()\n-    \n-    # Handle cases where averages might be NaN\n-    if pd.isna(avg_preferred_time):\n-        avg_preferred_time = 0\n-    if pd.isna(avg_delivery_time):\n-        avg_delivery_time = 0\n+# Define the data model\n+class DeliveryData(BaseModel):\n+    preferred_time: constr(regex=r'^[0-2]\\d:[0-5]\\d$')  # Ensures HH:MM format\n+    delivery_time: constr(regex=r'^[0-2]\\d:[0-5]\\d$')  # Ensures HH:MM format\n \n-    print(f'Average preferred time: {int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}')\n-    print(f'Average delivery time: {int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}')\n+@app.post(\"/process-data/\")\n+async def process_data(data: List[DeliveryData]):\n+    try:\n+        if not data:\n+            raise HTTPException(status_code=400, detail=\"No data provided\")\n \n-def visualize_data(df):\n-    \"\"\"Create and show visualizations from the DataFrame.\"\"\"\n-    # Convert times to minutes since midnight for plotting\n-    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-    \n-    plt.hist(df['delivery_time_minutes'], bins=24, edgecolor='k')\n-    plt.title('Distribution of Delivery Times')\n-    plt.xlabel('Minutes since Midnight')\n-    plt.ylabel('Frequency')\n-    plt.show()\n+        # Convert list of DeliveryData to DataFrame\n+        df = pd.DataFrame([item.dict() for item in data])\n \n-def visualize_comparison(df):\n-    \"\"\"Compare preferred and delivery times in a scatter plot.\"\"\"\n-    plt.figure(figsize=(10, 6))\n-    plt.scatter(\n-        df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute),\n-        df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute),\n-        alpha=0.5\n-    )\n-    plt.title('Preferred Time vs Delivery Time')\n-    plt.xlabel('Preferred Time (Minutes since Midnight)')\n-    plt.ylabel('Delivery Time (Minutes since Midnight)')\n-    plt.grid(True)\n-    plt.show()\n+        # Convert time columns to datetime\n+        try:\n+            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        except ValueError:\n+            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n \n-def detailed_analysis(df):\n-    \"\"\"Perform detailed statistical analysis on the DataFrame.\"\"\"\n-    df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-    \n-    mean_preferred_time = df['preferred_time_minutes'].mean()\n-    std_preferred_time = df['preferred_time_minutes'].std()\n-    mean_delivery_time = df['delivery_time_minutes'].mean()\n-    std_delivery_time = df['delivery_time_minutes'].std()\n-    \n-    print(f'Mean Preferred Time: {mean_preferred_time // 60}:{mean_preferred_time % 60:02d} ± {std_preferred_time:.1f} minutes')\n-    print(f'Mean Delivery Time: {mean_delivery_time // 60}:{mean_delivery_time % 60:02d} ± {std_delivery_time:.1f} minutes')\n+        # Analyze Data\n+        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        \n+        avg_preferred_time = df['preferred_time_minutes'].mean()\n+        avg_delivery_time = df['delivery_time_minutes'].mean()\n \n-def build_model(df):\n-    \"\"\"Build and evaluate a simple linear regression model.\"\"\"\n-    df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-    df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        analysis_result = {\n+            'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n+            'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n+        }\n+        \n+        # Create and save visualization\n+        plt.figure(figsize=(10, 6))\n+        plt.scatter(\n+            df['preferred_time_minutes'],\n+            df['delivery_time_minutes'],\n+            alpha=0.5\n+        )\n+        plt.title('Preferred Time vs Delivery Time')\n+        plt.xlabel('Preferred Time (Minutes since Midnight)')\n+        plt.ylabel('Delivery Time (Minutes since Midnight)')\n+        plt.grid(True)\n+        \n+        buf = io.BytesIO()\n+        plt.savefig(buf, format='png')\n+        buf.seek(0)\n+        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n+        plt.close()  # Close the plot to free memory\n+        \n+        return {\n+            'analysis_result': analysis_result,\n+            'visualization': f'data:image/png;base64,{img_base64}'\n+        }\n+    except Exception as e:\n+        raise HTTPException(status_code=500, detail=str(e))\n \n-    X = df[['preferred_time_minutes']]\n-    y = df['delivery_time_minutes']\n-\n-    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n-    \n-    model = LinearRegression()\n-    model.fit(X_train, y_train)\n-    \n-    y_pred = model.predict(X_test)\n-    mse = mean_squared_error(y_test, y_pred)\n-    \n-    print(f'Mean Squared Error: {mse:.2f}')\n-    return model\n-\n-def export_data(df, output_file):\n-    \"\"\"Export DataFrame to a CSV file.\"\"\"\n-    df.to_csv(output_file, index=False)\n-\n-def main():\n-    # Paths\n-    json_file = 'delivery.json'\n-    csv_file = 'processed_delivery_data.csv'\n-\n-    # Load, process, analyze, and visualize data\n-    data = load_data(json_file)\n-    df = process_data(data)\n-    analyze_data(df)\n-    visualize_data(df)\n-    visualize_comparison(df)  # New visualization\n-    detailed_analysis(df)     # Detailed analysis\n-    model = build_model(df)   # Model building\n-    export_data(df, csv_file)\n-\n-if __name__ == '__main__':\n-    main()\n+@app.post(\"/predict-delivery-time/\")\n+async def predict_delivery_time(data: DeliveryData):\n+    try:\n+        # Convert the input data to a DataFrame\n+        input_data = pd.DataFrame([data.dict()])\n+        input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n+        input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        \n+        # Make prediction\n+        prediction = model.predict(input_data[['preferred_time_minutes']])\n+        \n+        # Convert prediction to time format\n+        predicted_time = int(prediction[0])\n+        predicted_hours = predicted_time // 60\n+        predicted_minutes = predicted_time % 60\n+        \n+        return {\n+            'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n+        }\n+    except Exception as e:\n+        raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725470672320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,10 +19,10 @@\n     raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n-    preferred_time: constr(regex=r'^[0-2]\\d:[0-5]\\d$')  # Ensures HH:MM format\n-    delivery_time: constr(regex=r'^[0-2]\\d:[0-5]\\d$')  # Ensures HH:MM format\n+    preferred_time: constr(regex=r'^[0-2][0-9]:[0-5][0-9]$')  # HH:MM format\n+    delivery_time: constr(regex=r'^[0-2][0-9]:[0-5][0-9]$')  # HH:MM format\n \n @app.post(\"/process-data/\")\n async def process_data(data: List[DeliveryData]):\n     try:\n"
                },
                {
                    "date": 1725470775031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n from fastapi import FastAPI, HTTPException\n-from pydantic import BaseModel, constr\n+from pydantic import BaseModel\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n-from typing import List\n+from typing import List, Dict, Any\n import pickle\n \n app = FastAPI()\n \n@@ -19,10 +19,10 @@\n     raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n-    preferred_time: constr(regex=r'^[0-2][0-9]:[0-5][0-9]$')  # HH:MM format\n-    delivery_time: constr(regex=r'^[0-2][0-9]:[0-5][0-9]$')  # HH:MM format\n+    preferred_time: str  # Assuming HH:MM format\n+    delivery_time: str   # Assuming HH:MM format\n \n @app.post(\"/process-data/\")\n async def process_data(data: List[DeliveryData]):\n     try:\n"
                },
                {
                    "date": 1725471464188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,10 +3,10 @@\n import pandas as pd\n import matplotlib.pyplot as plt\n import io\n import base64\n-from typing import List, Dict, Any\n import pickle\n+from typing import List\n \n app = FastAPI()\n \n # Load the trained model\n@@ -73,8 +73,9 @@\n             'analysis_result': analysis_result,\n             'visualization': f'data:image/png;base64,{img_base64}'\n         }\n     except Exception as e:\n+        print(f\"Exception occurred: {str(e)}\")  # Add this line for debugging\n         raise HTTPException(status_code=500, detail=str(e))\n \n @app.post(\"/predict-delivery-time/\")\n async def predict_delivery_time(data: DeliveryData):\n@@ -95,5 +96,6 @@\n         return {\n             'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n         }\n     except Exception as e:\n+        print(f\"Exception occurred: {str(e)}\")  # Add this line for debugging\n         raise HTTPException(status_code=500, detail=str(e))\n"
                },
                {
                    "date": 1725479587237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,19 +4,27 @@\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n+import logging\n from typing import List\n \n+# Set up logging\n+logging.basicConfig(level=logging.INFO)\n+\n app = FastAPI()\n \n # Load the trained model\n try:\n-    with open('trained_model.pkl', 'rb') as model_file:\n-        model = pickle.load(model_file)\n+    with open('trained_model.pkl', 'rb') as f:\n+        model = pickle.load(f)\n+    logging.info(\"Trained model loaded successfully.\")\n+    logging.info(f\"Model type: {type(model)}\")  # Debugging line to check model type\n except FileNotFoundError:\n+    logging.error(\"Trained model file not found.\")\n     raise RuntimeError(\"Trained model file not found.\")\n except Exception as e:\n+    logging.error(f\"Error loading model: {str(e)}\")\n     raise RuntimeError(f\"Error loading model: {str(e)}\")\n \n # Define the data model\n class DeliveryData(BaseModel):\n@@ -30,28 +38,43 @@\n             raise HTTPException(status_code=400, detail=\"No data provided\")\n \n         # Convert list of DeliveryData to DataFrame\n         df = pd.DataFrame([item.dict() for item in data])\n-\n+        \n         # Convert time columns to datetime\n         try:\n             df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n             df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n         except ValueError:\n             raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n \n-        # Analyze Data\n+        # Convert time columns to minutes since midnight for analysis and prediction\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n         \n         avg_preferred_time = df['preferred_time_minutes'].mean()\n         avg_delivery_time = df['delivery_time_minutes'].mean()\n \n+        if pd.isna(avg_preferred_time):\n+            avg_preferred_time = 0\n+        if pd.isna(avg_delivery_time):\n+            avg_delivery_time = 0\n+\n         analysis_result = {\n             'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n             'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n         }\n         \n+        # Make predictions using the trained model\n+        X = df[['preferred_time_minutes']]\n+        try:\n+            predictions = model.predict(X)\n+        except AttributeError:\n+            raise HTTPException(status_code=500, detail=\"Model does not have a predict method.\")\n+        \n+        # Prepare prediction results\n+        prediction_results = list(predictions)\n+\n         # Create and save visualization\n         plt.figure(figsize=(10, 6))\n         plt.scatter(\n             df['preferred_time_minutes'],\n@@ -70,12 +93,13 @@\n         plt.close()  # Close the plot to free memory\n         \n         return {\n             'analysis_result': analysis_result,\n-            'visualization': f'data:image/png;base64,{img_base64}'\n+            'visualization': f'data:image/png;base64,{img_base64}',\n+            'predictions': prediction_results\n         }\n     except Exception as e:\n-        print(f\"Exception occurred: {str(e)}\")  # Add this line for debugging\n+        logging.error(f\"Exception occurred: {str(e)}\")\n         raise HTTPException(status_code=500, detail=str(e))\n \n @app.post(\"/predict-delivery-time/\")\n async def predict_delivery_time(data: DeliveryData):\n@@ -85,9 +109,14 @@\n         input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n         input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         \n         # Make prediction\n-        prediction = model.predict(input_data[['preferred_time_minutes']])\n+        if isinstance(model, np.ndarray):\n+            # If the model is a NumPy array, use it as a feature matrix and make the prediction manually\n+            prediction = model @ input_data['preferred_time_minutes'].to_numpy().T\n+        else:\n+            # If the model is a scikit-learn model, use the predict method\n+            prediction = model.predict(input_data[['preferred_time_minutes']])\n         \n         # Convert prediction to time format\n         predicted_time = int(prediction[0])\n         predicted_hours = predicted_time // 60\n@@ -96,6 +125,6 @@\n         return {\n             'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n         }\n     except Exception as e:\n-        print(f\"Exception occurred: {str(e)}\")  # Add this line for debugging\n-        raise HTTPException(status_code=500, detail=str(e))\n+        logging.error(f\"Exception occurred: {str(e)}\")\n+        raise HTTPException(status_code=500, detail=str(e))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725479693669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,22 +107,22 @@\n         # Convert the input data to a DataFrame\n         input_data = pd.DataFrame([data.dict()])\n         input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n         input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        \n+\n         # Make prediction\n         if isinstance(model, np.ndarray):\n             # If the model is a NumPy array, use it as a feature matrix and make the prediction manually\n             prediction = model @ input_data['preferred_time_minutes'].to_numpy().T\n         else:\n             # If the model is a scikit-learn model, use the predict method\n             prediction = model.predict(input_data[['preferred_time_minutes']])\n-        \n+\n         # Convert prediction to time format\n         predicted_time = int(prediction[0])\n         predicted_hours = predicted_time // 60\n         predicted_minutes = predicted_time % 60\n-        \n+\n         return {\n             'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n         }\n     except Exception as e:\n"
                },
                {
                    "date": 1725479769145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n from fastapi import FastAPI, HTTPException\n from pydantic import BaseModel\n import pandas as pd\n+import numpy as np\n import matplotlib.pyplot as plt\n import io\n import base64\n import pickle\n"
                },
                {
                    "date": 1725480282369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,131 +1,10 @@\n-from fastapi import FastAPI, HTTPException\n-from pydantic import BaseModel\n-import pandas as pd\n-import numpy as np\n-import matplotlib.pyplot as plt\n-import io\n-import base64\n-import pickle\n-import logging\n-from typing import List\n+from fastapi import FastAPI\n+from app import process_data\n \n-# Set up logging\n-logging.basicConfig(level=logging.INFO)\n-\n app = FastAPI()\n \n-# Load the trained model\n-try:\n-    with open('trained_model.pkl', 'rb') as f:\n-        model = pickle.load(f)\n-    logging.info(\"Trained model loaded successfully.\")\n-    logging.info(f\"Model type: {type(model)}\")  # Debugging line to check model type\n-except FileNotFoundError:\n-    logging.error(\"Trained model file not found.\")\n-    raise RuntimeError(\"Trained model file not found.\")\n-except Exception as e:\n-    logging.error(f\"Error loading model: {str(e)}\")\n-    raise RuntimeError(f\"Error loading model: {str(e)}\")\n+app.include_router(process_data)\n \n-# Define the data model\n-class DeliveryData(BaseModel):\n-    preferred_time: str  # Assuming HH:MM format\n-    delivery_time: str   # Assuming HH:MM format\n-\n-@app.post(\"/process-data/\")\n-async def process_data(data: List[DeliveryData]):\n-    try:\n-        if not data:\n-            raise HTTPException(status_code=400, detail=\"No data provided\")\n-\n-        # Convert list of DeliveryData to DataFrame\n-        df = pd.DataFrame([item.dict() for item in data])\n-        \n-        # Convert time columns to datetime\n-        try:\n-            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n-            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n-        except ValueError:\n-            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n-\n-        # Convert time columns to minutes since midnight for analysis and prediction\n-        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n-        \n-        avg_preferred_time = df['preferred_time_minutes'].mean()\n-        avg_delivery_time = df['delivery_time_minutes'].mean()\n-\n-        if pd.isna(avg_preferred_time):\n-            avg_preferred_time = 0\n-        if pd.isna(avg_delivery_time):\n-            avg_delivery_time = 0\n-\n-        analysis_result = {\n-            'average_preferred_time': f'{int(avg_preferred_time // 60)}:{int(avg_preferred_time % 60):02d}',\n-            'average_delivery_time': f'{int(avg_delivery_time // 60)}:{int(avg_delivery_time % 60):02d}'\n-        }\n-        \n-        # Make predictions using the trained model\n-        X = df[['preferred_time_minutes']]\n-        try:\n-            predictions = model.predict(X)\n-        except AttributeError:\n-            raise HTTPException(status_code=500, detail=\"Model does not have a predict method.\")\n-        \n-        # Prepare prediction results\n-        prediction_results = list(predictions)\n-\n-        # Create and save visualization\n-        plt.figure(figsize=(10, 6))\n-        plt.scatter(\n-            df['preferred_time_minutes'],\n-            df['delivery_time_minutes'],\n-            alpha=0.5\n-        )\n-        plt.title('Preferred Time vs Delivery Time')\n-        plt.xlabel('Preferred Time (Minutes since Midnight)')\n-        plt.ylabel('Delivery Time (Minutes since Midnight)')\n-        plt.grid(True)\n-        \n-        buf = io.BytesIO()\n-        plt.savefig(buf, format='png')\n-        buf.seek(0)\n-        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n-        plt.close()  # Close the plot to free memory\n-        \n-        return {\n-            'analysis_result': analysis_result,\n-            'visualization': f'data:image/png;base64,{img_base64}',\n-            'predictions': prediction_results\n-        }\n-    except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n-\n-@app.post(\"/predict-delivery-time/\")\n-async def predict_delivery_time(data: DeliveryData):\n-    try:\n-        # Convert the input data to a DataFrame\n-        input_data = pd.DataFrame([data.dict()])\n-        input_data['preferred_time'] = pd.to_datetime(input_data['preferred_time'], format='%H:%M').dt.time\n-        input_data['preferred_time_minutes'] = input_data['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n-\n-        # Make prediction\n-        if isinstance(model, np.ndarray):\n-            # If the model is a NumPy array, use it as a feature matrix and make the prediction manually\n-            prediction = model @ input_data['preferred_time_minutes'].to_numpy().T\n-        else:\n-            # If the model is a scikit-learn model, use the predict method\n-            prediction = model.predict(input_data[['preferred_time_minutes']])\n-\n-        # Convert prediction to time format\n-        predicted_time = int(prediction[0])\n-        predicted_hours = predicted_time // 60\n-        predicted_minutes = predicted_time % 60\n-\n-        return {\n-            'predicted_delivery_time': f'{predicted_hours}:{predicted_minutes:02d}'\n-        }\n\\ No newline at end of file\n-    except Exception as e:\n-        logging.error(f\"Exception occurred: {str(e)}\")\n-        raise HTTPException(status_code=500, detail=str(e))\n+if __name__ == \"__main__\":\n+    import uvicorn\n+    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725480297585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,82 @@\n-from fastapi import FastAPI\n-from app import process_data\n+from fastapi import FastAPI, HTTPException, APIRouter\n+from pydantic import BaseModel\n+import pandas as pd\n+import matplotlib.pyplot as plt\n+import io\n+import base64\n+from typing import List\n+import json\n\\ No newline at end of file\n \n-app = FastAPI()\n+# Set up logging\n+import logging\n+logging.basicConfig(level=logging.INFO)\n \n-app.include_router(process_data)\n+# Define the data model\n+class DeliveryData(BaseModel):\n+    recipient_id: str\n+    preferred_time: str  # Assuming HH:MM format\n+    delivery_date: str\n+    delivery_time: str   # Assuming HH:MM format\n+    location: dict\n+    day_of_week: str\n+    special_event: str\n \n-if __name__ == \"__main__\":\n-    import uvicorn\n-    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n+process_data = APIRouter()\n+\n+@process_data.post(\"/process-data/\")\n+async def process_data_endpoint(data: List[DeliveryData]):\n+    try:\n+        # Load the JSON data\n+        with open('delivery.json', 'r') as file:\n+            delivery_data = json.load(file)\n+\n+        # Convert list of DeliveryData to DataFrame\n+        df = pd.DataFrame([item.dict() for item in data])\n+\n+        # Convert time columns to datetime\n+        try:\n+            df['preferred_time'] = pd.to_datetime(df['preferred_time'], format='%H:%M').dt.time\n+            df['delivery_time'] = pd.to_datetime(df['delivery_time'], format='%H:%M').dt.time\n+        except ValueError:\n+            raise HTTPException(status_code=400, detail=\"Invalid time format, should be HH:MM\")\n+\n+        # Convert time columns to minutes since midnight for analysis and prediction\n+        df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n+        df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n+\n+        # Group the data by location and find the optimal delivery time for each location\n+        location_groups = df.groupby(['location.city', 'location.region', 'location.postal_code'])\n+        optimal_delivery_times = {}\n+\n+        for group, group_df in location_groups:\n+            city, region, postal_code = group\n+            location_key = f\"{city}, {region} - {postal_code}\"\n+            preferred_times = group_df['preferred_time_minutes'].tolist()\n+            optimal_delivery_time = min(preferred_times)\n+            optimal_delivery_times[location_key] = optimal_delivery_time\n+\n+        # Create and save visualization\n+        plt.figure(figsize=(10, 6))\n+        plt.scatter(\n+            df['preferred_time_minutes'],\n+            df['delivery_time_minutes'],\n+            alpha=0.5\n+        )\n+        plt.title('Preferred Time vs Delivery Time')\n+        plt.xlabel('Preferred Time (Minutes since Midnight)')\n+        plt.ylabel('Delivery Time (Minutes since Midnight)')\n+        plt.grid(True)\n+\n+        buf = io.BytesIO()\n+        plt.savefig(buf, format='png')\n+        buf.seek(0)\n+        img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n+        plt.close()  # Close the plot to free memory\n+\n+        return {\n+            'optimal_delivery_times': optimal_delivery_times,\n+            'visualization': f'data:image/png;base64,{img_base64}'\n+        }\n+    except Exception as e:\n+        logging.error(f\"Exception occurred: {str(e)}\")\n+        raise HTTPException(status_code=500, detail=str(e))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1725480442205,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,14 +44,13 @@\n         df['preferred_time_minutes'] = df['preferred_time'].apply(lambda x: x.hour * 60 + x.minute)\n         df['delivery_time_minutes'] = df['delivery_time'].apply(lambda x: x.hour * 60 + x.minute)\n \n         # Group the data by location and find the optimal delivery time for each location\n-        location_groups = df.groupby(['location.city', 'location.region', 'location.postal_code'])\n+        df['location_key'] = df.apply(lambda row: f\"{row['location']['city']}, {row['location']['region']} - {row['location']['postal_code']}\", axis=1)\n+        location_groups = df.groupby('location_key')\n         optimal_delivery_times = {}\n \n-        for group, group_df in location_groups:\n-            city, region, postal_code = group\n-            location_key = f\"{city}, {region} - {postal_code}\"\n+        for location_key, group_df in location_groups:\n             preferred_times = group_df['preferred_time_minutes'].tolist()\n             optimal_delivery_time = min(preferred_times)\n             optimal_delivery_times[location_key] = optimal_delivery_time\n \n"
                }
            ],
            "date": 1725456327762,
            "name": "Commit-0",
            "content": "v"
        }
    ]
}